@startuml

skinparam groupInheritance 2

title "STAM: Simple Stand-off Text Annotation Model"

class TextResource {
    --
    id : str
    text: str
    --
    _id : int
}


class AnnotationSet {
    id: str?
    annotations: [Annotation*]
    --
    _id: int
    _keys: [AnnotationKey*]
    _data: [AnnotationData*]
    --
    <i>A collection of annotations</i>
    <i>(grouping may be quite arbitrary)</i>
}

class Annotation {
    id: str?
    data: [&AnnotationData+]
    target: Selector
    --
    _id : int
    _referenced_by: [&Annotation*]
    --
    <i>An instance of an annotation</i>
}

abstract class Selector {
    --
    <i>Selects the target</i>
    <i>(or source) of annotation</i>
}

class TextSelector {
    resource: &TextResource,
    offsets: (begin: int, end: int)
    ---
    <i>Selects a single part of the text,</i>
    <i>Offsets are unicode codepoints,</i>
    <i>zero-indexed, end is non-inclusive,</i>

}

class ResourceSelector {
    resource: &TextResource
    ---
    <i>Selects a resource as a whole</i>
    <i>(i.e. metadata)</i>
}

class AnnotationSelector {
    annotation: &Annotation
    offsets: (begin: int, end: int)?
    --
    <i>Selects an annotation. May optionally</i>
    <i>select a only part of the annotation's target</i>
    <i>Offsets are unicode codepoints relative</i>
    <i>to the targeted annotation, </i>
    <i>zero-indexed, end is non-inclusive.</i>
}

class MultiSelector {
    selectors: [Selector+]
    --
    <i>Combines selectors</i>
}

class DirectedSelector {
    selectors: [Selector+]
    --
    <i>Expresses a direction between two or more selectors,</i>
    <i>in the exact order specified (from -> to)</i>
}

Selector <|-[#green]- TextSelector
Selector <|-[#green]- ResourceSelector
Selector <|-[#green]- AnnotationSelector
Selector <|-[#green]- MultiSelector
Selector <|-[#green]- DirectedSelector





class AnnotationData {
    id: str?
    key: &DataKey
    value: DataValue
    --
    _id : int
    _referenced_by: [&Annotation*]
    --
    <i>The value of the annotation</i>
    <i>Used for the body and for</i>
    <i>metadata</i>
}

class DataKey {
    id: str
    --
    _id: int
    _referenced_by: [&AnnotationData*]
    --
    <i>The key of an annotation</i>
}

enum DataValue {
    Id(v: str)
    String(v: str)
    Bool(v: bool)
    Int(v: int)
    Float(v: float)
    Datetime(v: datetime)
    Set(v: [DataValue])
    List(v: [DataValue])
    --
    <i>Encapsulates a data value</i>
    <i>along with its type</i>
}
' There is no Map() in DataValue, a Map should be expressed as an Annotation on an Annotation

AnnotationSet "1" *--> "*" Annotation : > annotations
AnnotationSet "1" *.[#blue].> "*" AnnotationData : > _data
AnnotationSet "1" *.[#blue].> "*" DataKey : > _keys

Annotation "1" *--> "+" Selector : > target
Annotation "1" o--> "*" AnnotationData : > data
Annotation "1" .[#red].> "*" Annotation : > _referenced_by

AnnotationData "1" .[#red].> "+" Annotation : > _referenced_by
AnnotationData "1" *--> "1" DataValue : > value
AnnotationData "1" *--> "1" DataKey : > key

TextSelector "1" --> "1" TextResource : > resource
ResourceSelector "1" --> "1" TextResource : > resource
AnnotationSelector "1" --> "+" Annotation : > annotation

DataKey "1" .[#red].> "+" AnnotationData : > _referenced_by

@enduml
